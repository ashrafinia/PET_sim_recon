% Gen_PSF_Kernels
% 
% This function generates 50 partial PSF kernels; including underestimation 
% and overestimation of the full PSF kernel.
% 
% The full PSF kernel is derived by simulating photon non-colinearity,
% inter-crystal scattering and inter-crystal penetration, which is #26.
% 
% The partial kernels are generated by variating the three constant factors
% of the above degredation models. 
% 
% The scanner parameters are also set in this file.
% 
% The kernel models are saved in the following variables:
%       KernelFull_hold :full kernel pattern (used to plot kernel contours)
%       KernelFull      : actual full PSF kernel
%       KernelsSet_hold : set of all kernels patterns
%       KernelsSet      : all partial kernels
% 
% Possibly the only variable may require changing is NUMVAR (# of kernels).
% -------------------------------------------------------------------------
% % AUTHOR: 
% - Saeed Ashrafinia
% -------------------------------------------------------------------------
% **** If you use this code in a study, please cite the following paper ***
% S. Ashrafinia, H. Mohy-ud-din, N. Karakatsanis, A. Jha, M. Casey, D.
% Kadrmas and A. Rahmim, “Generalized PSF modeling for optimized
% quantitative-task performance”, Phys. Med. Biol., vol. 62, pp. 5149-5179,
% 2017.   
% 
% -------------------------------------------------------------------------
% STATEMENT:
% This file is part of PET Recon Package by Saeed Ashrafinia, Rahmimlab.com
% --> Copyright (C) 2013-2017  Saeed Ashrafinia, Johns Hopkins University
% 
%    This package is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
% -------------------------------------------------------------------------

%% Initializing 
if PSF_Kernel == 0          % No PSF modeling
    Kernels2Select = 1;
elseif PSF_Kernel == 1      % True PSF Modeling
    Kernels2Select = 26;
elseif PSF_Kernel == 2      % No PSF + True PSF modeling
    Kernels2Select = [1, 26];
else                        % Generalized PSF modeling. 1 is no PSF, 26 is full PSF, 2 to 25 are underestimated PSFs, 27 till 50 are overestimated PSFs. 
%     Kernels2Select        = [1 3 6 11 15 18 20 22 24 26 28 30 32 34 36 38 40 42 44 45]; % 20 kernels out of 50. These are the kernels used in the PMB paper. 
    Kernels2Select        = [1 23 26 32 40]; % one underest, two over
    % Kernels2Select        = 26; % only full PSF
end

% Our partial kernel generation formula works for NUMVAR = 50; if we need
% less than that, we can truncate from the latter kernels. So we save
% NUMVAR first and at the end return the required number of kernels.

if ~exist('SUBSETS' , 'var') 
    SUBSETS    = 7;
end

NUMVAR         = 50;

%% Generating Scaling Factors to Produce Partial PSF Kernels
scatter_set         = (linspace(1 , NUMVAR , NUMVAR) .* 0.04) .^1 .* 3.27;
non_coll_fact_set   = (linspace(0 , NUMVAR - 1 , NUMVAR) .* 0.04) .^ 1 .* 0.0022;
mln                 = (0:0.1:5).*1/2.5; 
mu_set              = flip(sort(unique([mln(26 : 26+8)'             .* 0.087 ;
                                        mln(26+2 : 26+14)' .^7      .* 0.087 ;
                                        mln(26+12 : 3 : end)' .^7   .* 0.087 ;
                                        mln(2 : 26)'                .* 0.087 ]')));




%% Misc. Initializing
D       = 886;
r       = D/2;
rng('shuffle', 'twister');

% bin_size = 2.249; % Same as voxel size
FOV         = 600;
bin_size    = FOV/xdim; % Same as voxel size

% Number of bins and angels
if xdim == 128
    NUM_BINS = 185; % number of radial bins; 
elseif xdim == 256
    NUM_BINS = 367;
elseif xdim == 512
    NUM_BINS = 729;
elseif xdim == 1024
    NUM_BINS = 1453;
end

% NOTE: Not having enough angles can bias the images.
thdim       = pi / 2 * NUM_BINS;            % Number of angular bins; previously 314; Cherry's book; 
thdim       = (floor(thdim/SUBSETS)+1)*SUBSETS; % make thdim an multipicant of subsets
d_theta     = 180/thdim;
thdim_m     = thdim/SUBSETS;

% managing subsets
% theta       = 0 : d_theta : 179.99;
theta       = 0 : d_theta : 179.99;
theta_m     = reshape(theta ,SUBSETS ,length(theta)/SUBSETS)';
angles_m    = size(theta_m ,1);


KernelsSet_hold = zeros(NUM_BINS,15,NUMVAR);
KernelsSet  = zeros(NUM_BINS,NUM_BINS,NUMVAR);


%% Initial projection-space size and counts estimaton
Y_bar0      = zeros(NUM_BINS , angles_m , SUBSETS);

binsdim     = NUM_BINS; %size(Y_bar0,1); 

% warning ;
if binsdim*bin_size >= D
    warning('Object FOV hits the scanner!!');
    return
end

%% Start Generating Kernels 
for count_var = 1:NUMVAR % tmp_NUMVAR

    mu              = mu_set(count_var);
    scatter_fact    = scatter_set(count_var);
    non_coll_fact   = non_coll_fact_set(count_var);
    % Make sure the middle kernel get the full RM values
    if count_var == ceil(NUMVAR/2+1)
        mu              = 0.087;
        scatter_fact    = 3.27;
        non_coll_fact   = 0.0022;
    end

    %% Projection-space blurring model based on Rahmim  PMB2008 paper
    convolFINAL         = zeros(binsdim,binsdim);
    convolOVERALL_hold  = zeros(binsdim,15);

    % Key change was to make this have odd size so for DRF x==0 is
    % centered, so we can center properly below
    delta       = 1/11; % Changed to correct for the center
    x           = (-7.5+delta/2:delta:7.5).*bin_size;
%     delta = 1/10;                   % Changed to correct for the center
%     x=(-7.5:delta:7.5).*bin_size;   % Changed to correct for the center
    x           = round(x*1000)/1000;
    sizex       = size(x,2);
    halfsizex   = (sizex+1)/2;
    binsdimhalf = floor(binsdim/2);

    for bin = 1:binsdim
        source_pos  = (bin-(binsdim+1)/2)*bin_size; %mm from center
        %  source_pos=r*0.999;
        angle = asin(source_pos/r);  % in radians
        angle_deg = angle*180/pi;

        %%% 1) Penetration

        % 45 deg gives most blurring along x=x' cos(angle) where x' is tangential
        % direction, and x is bin direction
        if angle==0
            DRF=double(x==0);
        else
            % Undefined (delta function) when angle==0
            % Eq. (15) in PMB08 paper
            DRF=exp(-abs(mu*x/cos(angle)/sin(angle)));
        end

        % No penetration effect:
        % DRF=double(x==0);
        % keeping middle point included
        if source_pos>0
            DRF(halfsizex+1:sizex)=0;
        else
            DRF(1:halfsizex-1)=0;
        end

        convol=conv(DRF, DRF);
        convolDRF=convol(1:2:2*sizex);
        % we skip every two due to scale by factor of 2 (see Eq. 16 in Rahmim et al.)

        %%% 2) non-collinearity
        FWHM_noncollin=non_coll_fact*(2*r*cos(angle));

        %%% 3) scattering
        FWHM_scatter=scatter_fact*cos(angle);
        % As found in our PMB2008 studies (3.27 along x; 5.03 along y)

        FWHM=sqrt(FWHM_noncollin^2+FWHM_scatter^2);
        sigma=FWHM/2.355;
        convol2=exp(-(x.^2/sigma.^2));


        % Overall kernel
        convolOVERALL=conv(convolDRF, convol2,'same');
        convolOVERALL=convolOVERALL/sum(sum(convolOVERALL));
        convolOVERALL(isnan(convolOVERALL)) =0;
        % for transpose operation in resolutio modeling

        % Downsample now to actual bin size
        % size of x is odd above; and below we drop the very first element
        % to center it
        for jjj=1:15
                    if (bin+jjj-8)>=1 && (bin+jjj-8)<=binsdim
                        convolOVERALL_hold(bin,jjj)=sum(convolOVERALL((jjj-1)/delta+1:jjj/delta+0));
                        % Here we shift kernel to location of incidence
                        convolFINAL(bin,bin+jjj-8)=sum(convolOVERALL((jjj-1)/delta+1:jjj/delta+0));
                    end

%             % New from Arman
%             if (bin+jjj-8)>=1 && (bin+jjj-8)<=binsdim
%                 convolOVERALL_hold(bin,jjj)=sum(convolOVERALL((jjj-1)*10+2:jjj*10+1));
%                 % Here we shift kernel to location of incidence
%                 convolFINAL(bin,bin+jjj-8)=sum(convolOVERALL((jjj-1)*10+2:jjj*10+1));
%             end

        end
        convolFINAL(bin,:)=convolFINAL(bin,:)/sum(sum(convolFINAL(bin,:)));
    end
    convolFINAL_orig = convolFINAL;
    convolOVERALL_hold_orig = convolOVERALL_hold;
    convolFINAL_tr=transpose(convolFINAL);

    if count_var == ceil(NUMVAR/2+1)
        KernelFull_hold                 = convolOVERALL_hold_orig;
        KernelFull                      = convolFINAL;
    end
    KernelsSet_hold(:,:,count_var)  = convolOVERALL_hold;
    KernelsSet(:,:,count_var)       = convolFINAL;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

end

KernelsSet          = KernelsSet(:,:,Kernels2Select);
KernelsSet_hold     = KernelsSet_hold(:,:,Kernels2Select);

NUMVAR              = numel(Kernels2Select);



